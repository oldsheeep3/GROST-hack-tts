<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Text-to-Speech Demo</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      background: #1a1a2e;
      color: #eee;
    }
    h1 { color: #00d9ff; margin-bottom: 10px; }
    .status {
      padding: 10px 15px;
      border-radius: 8px;
      margin: 10px 0;
      font-weight: bold;
    }
    .status.disconnected { background: #c0392b; }
    .status.connected { background: #27ae60; }
    .status.processing { background: #2980b9; }
    .status.speaking { background: #8e44ad; }

    .controls {
      display: flex;
      gap: 10px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    button {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    button:hover { transform: scale(1.05); }
    button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    #connectBtn { background: #27ae60; color: white; }
    #disconnectBtn { background: #c0392b; color: white; }
    #sendBtn { background: #2980b9; color: white; }
    #cancelBtn { background: #e67e22; color: white; }

    .panel {
      background: #16213e;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
    }
    .panel h3 {
      margin: 0 0 10px 0;
      color: #00d9ff;
      font-size: 14px;
      text-transform: uppercase;
    }

    #textInput {
      width: 100%;
      min-height: 100px;
      padding: 12px;
      font-size: 16px;
      border: 2px solid #0f3460;
      border-radius: 8px;
      background: #0f0f23;
      color: #fff;
      font-family: inherit;
      resize: vertical;
    }
    #textInput:focus {
      outline: none;
      border-color: #00d9ff;
    }

    #responseText {
      font-size: 18px;
      min-height: 80px;
      color: #00d9ff;
      line-height: 1.6;
    }

    #log {
      font-family: 'Monaco', 'Consolas', monospace;
      font-size: 12px;
      background: #0f0f23;
      color: #0f0;
      padding: 10px;
      border-radius: 8px;
      max-height: 300px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-all;
    }

    .metrics {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }
    .metric {
      background: #0f3460;
      padding: 10px;
      border-radius: 8px;
      text-align: center;
    }
    .metric .value {
      font-size: 24px;
      font-weight: bold;
      color: #00d9ff;
    }
    .metric .label {
      font-size: 12px;
      color: #aaa;
      margin-top: 5px;
    }

    .example-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    .example-btn {
      padding: 8px 16px;
      font-size: 14px;
      background: #0f3460;
      color: #fff;
      border: 1px solid #00d9ff;
      border-radius: 6px;
      cursor: pointer;
    }
    .example-btn:hover {
      background: #00d9ff;
      color: #000;
    }
  </style>
</head>
<body>
  <h1>ğŸ™ï¸ Text-to-Speech Demo</h1>
  <p>ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã™ã‚‹ã¨ã€AI ãŒå¿œç­”ã‚’ç”Ÿæˆã—ã¦éŸ³å£°ã§è¿”ã—ã¾ã™ã€‚</p>

  <div id="status" class="status disconnected">æœªæ¥ç¶š</div>

  <div class="controls">
    <button id="connectBtn">æ¥ç¶š</button>
    <button id="disconnectBtn" disabled>åˆ‡æ–­</button>
    <button id="sendBtn" disabled>é€ä¿¡</button>
    <button id="cancelBtn" disabled>ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
  </div>

  <div class="panel">
    <h3>ğŸ“ å…¥åŠ›ãƒ†ã‚­ã‚¹ãƒˆ</h3>
    <textarea id="textInput" placeholder="ã“ã“ã«ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„...">ã“ã‚“ã«ã¡ã¯ï¼</textarea>
    <div class="example-buttons">
      <button class="example-btn" data-text="ã“ã‚“ã«ã¡ã¯ï¼">ã“ã‚“ã«ã¡ã¯</button>
      <button class="example-btn" data-text="ä»Šæ—¥ã®å¤©æ°—ã¯ã©ã†ã§ã™ã‹ï¼Ÿ">å¤©æ°—ã‚’èã</button>
      <button class="example-btn" data-text="é¢ç™½ã„è©±ã‚’èã‹ã›ã¦ãã ã•ã„">é¢ç™½ã„è©±</button>
      <button class="example-btn" data-text="è‡ªå·±ç´¹ä»‹ã—ã¦ãã ã•ã„">è‡ªå·±ç´¹ä»‹</button>
    </div>
  </div>

  <div class="panel">
    <h3>ğŸ’¬ AIå¿œç­”</h3>
    <div id="responseText">ã“ã“ã«å¿œç­”ãŒè¡¨ç¤ºã•ã‚Œã¾ã™...</div>
  </div>

  <div class="panel">
    <h3>ğŸ“Š ãƒ¡ãƒˆãƒªã‚¯ã‚¹</h3>
    <div class="metrics">
      <div class="metric">
        <div class="value" id="audioTime">0.0s</div>
        <div class="label">éŸ³å£°å†ç”Ÿæ™‚é–“</div>
      </div>
      <div class="metric">
        <div class="value" id="latency">0ms</div>
        <div class="label">ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·</div>
      </div>
      <div class="metric">
        <div class="value" id="statusMetric">-</div>
        <div class="label">ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
      </div>
    </div>
  </div>

  <div class="panel">
    <h3>ğŸ“‹ ãƒ­ã‚°</h3>
    <div id="log"></div>
  </div>

  <script>
    const statusDiv = document.getElementById('status');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const sendBtn = document.getElementById('sendBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const textInput = document.getElementById('textInput');
    const responseText = document.getElementById('responseText');
    const logDiv = document.getElementById('log');
    const audioTimeDiv = document.getElementById('audioTime');
    const latencyDiv = document.getElementById('latency');
    const statusMetric = document.getElementById('statusMetric');

    let ws = null;
    let audioContext = null;
    let audioQueue = [];
    let isPlaying = false;
    let currentSource = null;
    let requestTime = 0;
    let firstChunkTime = 0;
    let totalAudioTime = 0;
    let pendingQueueSize = 0;  // ä¿ç•™ä¸­ã®ãƒ†ã‚­ã‚¹ãƒˆæ•°

    // ä¾‹æ–‡ãƒœã‚¿ãƒ³
    document.querySelectorAll('.example-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        textInput.value = btn.dataset.text;
      });
    });

    function log(msg) {
      const timestamp = new Date().toLocaleTimeString('ja-JP', { hour12: false });
      logDiv.textContent += `[${timestamp}] ${msg}\n`;
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    function updateStatus(state, text) {
      statusDiv.className = `status ${state}`;
      statusDiv.textContent = text;
      statusMetric.textContent = text;
    }

    async function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate: 44100
        });
        log('AudioContext initialized @ 44.1kHz');
      }
    }

    async function playAudioBuffer(pcmData) {
      if (!audioContext) await initAudio();

      // PCM int16 ãƒã‚¤ãƒŠãƒªã‚’ Float32 ã«å¤‰æ›
      const int16Array = new Int16Array(pcmData);
      const float32Array = new Float32Array(int16Array.length);
      for (let i = 0; i < int16Array.length; i++) {
        float32Array[i] = int16Array[i] / 32768.0;
      }

      const audioBuffer = audioContext.createBuffer(1, float32Array.length, 44100);
      audioBuffer.getChannelData(0).set(float32Array);

      audioQueue.push(audioBuffer);
      if (!isPlaying) {
        playNextInQueue();
      }
    }

    function playNextInQueue() {
      if (audioQueue.length === 0) {
        isPlaying = false;
        updateStatus('connected', 'æ¥ç¶šä¸­ï¼ˆå¾…æ©Ÿï¼‰');
        return;
      }

      isPlaying = true;
      const buffer = audioQueue.shift();
      
      currentSource = audioContext.createBufferSource();
      currentSource.buffer = buffer;
      currentSource.connect(audioContext.destination);
      
      currentSource.onended = () => {
        playNextInQueue();
      };

      const duration = buffer.duration;
      totalAudioTime += duration;
      audioTimeDiv.textContent = `${totalAudioTime.toFixed(1)}s`;

      currentSource.start();
      updateStatus('speaking', 'å†ç”Ÿä¸­');
    }

    function stopAudio() {
      if (currentSource) {
        currentSource.stop();
        currentSource = null;
      }
      audioQueue = [];
      isPlaying = false;
    }

    connectBtn.addEventListener('click', async () => {
      try {
        await initAudio();
        
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws/tts`;
        
        ws = new WebSocket(wsUrl);
        
        ws.onopen = () => {
          log('WebSocket connected');
          updateStatus('connected', 'æ¥ç¶šä¸­ï¼ˆå¾…æ©Ÿï¼‰');
          connectBtn.disabled = true;
          disconnectBtn.disabled = false;
          sendBtn.disabled = false;
          
          // è¨­å®šã‚’é€ä¿¡
          ws.send(JSON.stringify({ type: 'config', mode: 'text-to-speech' }));
        };

        ws.onclose = () => {
          log('WebSocket closed');
          updateStatus('disconnected', 'æœªæ¥ç¶š');
          connectBtn.disabled = false;
          disconnectBtn.disabled = true;
          sendBtn.disabled = true;
          cancelBtn.disabled = true;
          stopAudio();
        };

        ws.onerror = (err) => {
          log(`WebSocket error: ${err}`);
        };

        ws.onmessage = async (event) => {
          if (typeof event.data === 'string') {
            // ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆï¼‰
            try {
              const msg = JSON.parse(event.data);
              handleEvent(msg);
            } catch (e) {
              log(`JSON parse error: ${e}`);
            }
          } else {
            // ãƒã‚¤ãƒŠãƒªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆéŸ³å£°ï¼‰
            const arrayBuffer = await event.data.arrayBuffer();
            await playAudioBuffer(arrayBuffer);
            
            if (firstChunkTime === 0) {
              firstChunkTime = Date.now();
              const latency = firstChunkTime - requestTime;
              latencyDiv.textContent = `${latency}ms`;
              log(`First audio chunk latency: ${latency}ms`);
            }
          }
        };

      } catch (error) {
        log(`Connection error: ${error}`);
      }
    });

    disconnectBtn.addEventListener('click', () => {
      if (ws) {
        ws.close();
        ws = null;
      }
    });

    sendBtn.addEventListener('click', () => {
      const text = textInput.value.trim();
      if (!text || !ws) return;

      log(`Sending text: "${text}"`);
      requestTime = Date.now();
      firstChunkTime = 0;
      totalAudioTime = 0;
      responseText.textContent = '';
      
      ws.send(JSON.stringify({ type: 'text', text: text }));
      
      updateStatus('processing', 'å‡¦ç†ä¸­');
      sendBtn.disabled = true;
      cancelBtn.disabled = false;
    });

    cancelBtn.addEventListener('click', () => {
      if (!ws) return;
      
      log('Cancelling queued items and current generation');
      ws.send(JSON.stringify({ type: 'cancel' }));
      stopAudio();
      pendingQueueSize = 0;
      responseText.textContent = '';
      cancelBtn.disabled = true;
    });

    // Enterã‚­ãƒ¼ã§é€ä¿¡ï¼ˆShift+Enterã§æ”¹è¡Œï¼‰
    textInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        if (!sendBtn.disabled) {
          sendBtn.click();
        }
      }
    });

    function handleEvent(msg) {
      const { name, ...payload } = msg;
      
      switch (name) {
        case 'session_start':
          log('Session started');
          break;
          
        case 'config_ack':
          log('Config acknowledged');
          break;
          
        case 'text_queued':
          log(`Text queued: "${payload.text}" (queue size: ${payload.queue_size})`);
          pendingQueueSize = payload.queue_size;
          updateStatus('processing', `å¾…æ©Ÿä¸­... ã‚­ãƒ¥ãƒ¼: ${payload.queue_size}`);
          break;
          
        case 'text_received':
          log(`Text received: "${payload.text}"`);
          break;
          
        case 'llm_start':
          log(`LLM generating response for: "${payload.user_text}"`);
          updateStatus('processing', 'AIæ€è€ƒä¸­');
          break;
          
        case 'tts_start':
          log(`TTS started: "${payload.text}"`);
          responseText.textContent += payload.text;
          break;
          
        case 'tts_done':
          log(`TTS done: ${payload.duration_ms}ms @ ${payload.sample_rate}Hz`);
          break;
          
        case 'llm_end':
          const reason = payload.reason || 'completed';
          log(`LLM ended: ${reason}`);
          pendingQueueSize = Math.max(0, pendingQueueSize - 1);
          
          if (pendingQueueSize > 0) {
            updateStatus('processing', `å¾…æ©Ÿä¸­... ã‚­ãƒ¥ãƒ¼: ${pendingQueueSize}`);
          } else {
            updateStatus('connected', 'æ¥ç¶šä¸­ï¼ˆå¾…æ©Ÿï¼‰');
          }
          
          sendBtn.disabled = false;
          cancelBtn.disabled = true;
          break;
          
        case 'error':
          log(`ERROR: ${payload.message}`);
          updateStatus('connected', 'ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ');
          sendBtn.disabled = false;
          cancelBtn.disabled = true;
          break;
          
        case 'pong':
          // ping/pong
          break;
          
        default:
          log(`Unknown event: ${name}`);
      }
    }

    // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚
    log('Page loaded. Click "æ¥ç¶š" to start.');
  </script>
</body>
</html>
